{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Backpropagation exercise\n",
    "In the previous homework, you implemented a softmax classifier on mnist. The implementation was simple but not very modular since the loss and gradient were computed in a single monolithic function. This is manageable for a simple one-layer network, but would become impractical as we move to bigger models. Ideally we want to build networks using a more modular design so that we can implement different layer typess in isolation and then snap them together into models with different architectures.\n",
    "\n",
    "In this exercise we will implemtn fully-connected networks using a more modular approach. For each layer we will implement a <code>forward</code> and a <code>backward</code> function. The <code>forward</code> function will receive inputs, weights, and other parameters and will return both an output and a <code>cache</code> object storing data needed for the backward pass like this:\n",
    "\n",
    "```python\n",
    "def layer_forward(x, w):\n",
    "    \"\"\" Receive inputs x and weights w \"\"\"\n",
    "    # Do some computations ...\n",
    "    z = # ... sime intermediate value\n",
    "    # Do some more computations ...\n",
    "    out = # the output\n",
    "    \n",
    "    cache = (x, w, z, out) # Values we need to compute gradients\n",
    "    return (out, cache)\n",
    "```\n",
    "\n",
    "The backward pass will receive upstream derivatives and the <code>cache</code> object, and will return gradients with respect to the input and weights like this:\n",
    "\n",
    "```python\n",
    "def layer_backward(dout, cache):\n",
    "    \"\"\"\n",
    "    Receive derivative of loss with respect to outputs and cache, and compute derivative with respect to inputs.\n",
    "    \"\"\"\n",
    "    # Unpack cache values\n",
    "    x, w, z, out = cache\n",
    "    \n",
    "    # Use values in cache to compute derivatives\n",
    "    dx = # Derivative of loss with respect to x\n",
    "    dw = # Derivative of loss with respect to w\n",
    "    \n",
    "    return dx, dw\n",
    "```\n",
    "\n",
    "After implementing a bunch of layers this way,we will be able to easily combine them to build classifiers with different architectures.\n",
    "\n",
    "In addition to implement fully-connected networks of arbitrary depth, we will also explore different update rules for optimization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using TensorFlow backend.\n"
     ]
    }
   ],
   "source": [
    "from keras.datasets import fashion_mnist\n",
    "from sklearn.model_selection import StratifiedShuffleSplit\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "def rel_error(x, y):\n",
    "  \"\"\" returns relative error \"\"\"\n",
    "  return np.max(np.abs(x - y) / (np.maximum(1e-8, np.abs(x) + np.abs(y))))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X_train.shape  (60000, 28, 28)\n",
      "y_train.shape  (60000,)\n",
      "X_test.shape   (10000, 28, 28)\n",
      "y_test.shape   (10000,)\n",
      "6000 data of T-shirt/top\n",
      "6000 data of Trouser\n",
      "6000 data of Pullover\n",
      "6000 data of Dress\n",
      "6000 data of Coat\n",
      "6000 data of Sandal\n",
      "6000 data of Shirt\n",
      "6000 data of Sneaker\n",
      "6000 data of Bag\n",
      "6000 data of Ankle boot\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 9 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "nb_classes = 10\n",
    "class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat', 'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']\n",
    "(X_train, y_train), (X_test, y_test) = fashion_mnist.load_data()\n",
    "\n",
    "#############################################################################\n",
    "# TODO: Print the shape of the training data and testing data               #\n",
    "# Plot the previous 9 training data and title their class name              #\n",
    "# Count the number of data for each class in training data                  #\n",
    "#############################################################################\n",
    "# raise NotImplementedError()\n",
    "\n",
    "print(\"X_train.shape  {}\".format(X_train.shape))\n",
    "print(\"y_train.shape  {}\".format(y_train.shape))\n",
    "print(\"X_test.shape   {}\".format(X_test.shape))\n",
    "print(\"y_test.shape   {}\".format(y_test.shape))\n",
    "\n",
    "ar1,ar2 = np.unique(y_train, return_counts=True)\n",
    "for i in range(len(ar1)):\n",
    "    print((\"{} data of \" + class_names[i]).format(ar2[i]))\n",
    "\n",
    "\n",
    "from matplotlib import pyplot as plt\n",
    "\n",
    "fig, axar =plt.subplots(3,3)\n",
    "plt.tight_layout()\n",
    "for i in range(0,9):\n",
    "    axar[int(i/3),i%3].set_title(str(class_names[y_train[i]]))\n",
    "    axar[int(i/3),i%3].imshow(X_train[i])\n",
    "\n",
    "#############################################################################\n",
    "#                          END OF YOUR CODE                                 #\n",
    "#############################################################################"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train data shape: (6000, 28, 28)\n",
      "Train label shape: (6000,)\n",
      "Validation data shape: (6000, 28, 28)\n",
      "Validation label shape: (6000,)\n",
      "Test data shape: (2000, 28, 28)\n",
      "Test label shape: (2000,)\n"
     ]
    }
   ],
   "source": [
    "# data prepration for binary classification\n",
    "not_n = 6\n",
    "def get_binary_data(X_train, y_train, X_test, y_test):\n",
    "    \n",
    "    # normalization\n",
    "    X_train = X_train / 255.\n",
    "    X_test = X_test / 255.\n",
    "    \n",
    "    # reshape\n",
    "    y_train = np.array(y_train)\n",
    "    y_test = np.array(y_test)\n",
    "    \n",
    "    # binarize\n",
    "    y_train[y_train != not_n] = 0.\n",
    "    y_train[y_train == not_n] = 1.\n",
    "    y_test[y_test != not_n] = 0.\n",
    "    y_test[y_test == not_n] = 1.\n",
    "\n",
    "    X = np.array(X_train)\n",
    "    y = np.array(y_train)\n",
    "    \n",
    "    # split train and validation\n",
    "    sss = StratifiedShuffleSplit(n_splits = 10, test_size = 0.5, random_state = 0)\n",
    "    for train_idx, val_idx in sss.split(X_train, y_train):\n",
    "        X_train, X_val = X[train_idx], X[val_idx]\n",
    "        y_train, y_val = y[train_idx], y[val_idx]\n",
    "    \n",
    "    X_train, y_train = subsampling(X_train, y_train)\n",
    "    X_val, y_val = subsampling(X_val, y_val)\n",
    "    X_test, y_test = subsampling(X_test, y_test)\n",
    "    \n",
    "    return X_train, y_train, X_val, y_val, X_test, y_test\n",
    "\n",
    "def subsampling(X, y):\n",
    "    unique, count = np.unique(y, return_counts = True)\n",
    "    n_sampling = count[np.argmin(count)]\n",
    "    \n",
    "    idx_list = []\n",
    "    for i in range(len(unique)):\n",
    "        if count[i] <= n_sampling:\n",
    "            idx_list.append(np.where(y == unique[i])[0])\n",
    "            continue\n",
    "        idx = np.where(y == unique[i])[0]\n",
    "        idx = np.random.choice(idx, n_sampling, replace = False)\n",
    "        idx_list.append(idx)\n",
    "    \n",
    "    all_idx = np.sort(np.concatenate(idx_list))\n",
    "    X_sub = X[all_idx]\n",
    "    y_sub = y[all_idx]\n",
    "    \n",
    "    return X_sub, y_sub\n",
    "\n",
    "# Invoke the above function to get our data\n",
    "X_train, y_train, X_val, y_val, X_test, y_test = get_binary_data(X_train, y_train, X_test, y_test)\n",
    "print('Train data shape: {}'.format(X_train.shape))\n",
    "print('Train label shape: {}'.format(y_train.shape))\n",
    "print('Validation data shape: {}'.format(X_val.shape))\n",
    "print('Validation label shape: {}'.format(y_val.shape))\n",
    "print('Test data shape: {}'.format(X_test.shape))\n",
    "print('Test label shape: {}'.format(y_test.shape))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Affine layer: forward\n",
    "Implement the <code>affine_forward</code> function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Testing affine_forward function:\n",
      "difference: 9.769848308602077e-10\n"
     ]
    }
   ],
   "source": [
    "def affine_forward(x, w, b, a):\n",
    "    \"\"\"\n",
    "    Computes the forward pass for an affine (fully-connected) layer.\n",
    "\n",
    "    The input x has shape (N, d_1, ..., d_k) and contains a minibatch of N\n",
    "    examples, where each example x[i] has shape (d_1, ..., d_k). We will\n",
    "    reshape each input into a vector of dimension D = d_1 * ... * d_k, and\n",
    "    then transform it to an output vector of dimension M.\n",
    "\n",
    "    Inputs:\n",
    "    - x: A numpy array containing input data, of shape (N, d_1, ..., d_k)\n",
    "    - w: A numpy array of weights, of shape (D, M)\n",
    "    - b: A numpy array of biases, of shape (M,)\n",
    "    - a: A function of activation\n",
    "\n",
    "    Returns a tuple of:\n",
    "    - out: output, of shape (N, M)\n",
    "    - cache: (x, w, b)\n",
    "    \"\"\"\n",
    "    out = None\n",
    "    ###########################################################################\n",
    "    # TODO: Implement the affine forward pass. Store the result in out. You   #\n",
    "    # will need to reshape the input into rows.                               #\n",
    "    ###########################################################################\n",
    "#     raise NotImplementedError()\n",
    "    N = x.shape[0]\n",
    "    D = w.shape[0]\n",
    "    M = w.shape[1]\n",
    "    x_reshape = x.reshape((N,D))\n",
    "    z = np.empty((N,M))\n",
    "    out = np.empty((N,M))\n",
    "    \n",
    "    for i in range(N):\n",
    "        z[i] = np.dot(x_reshape[i], w) + b\n",
    "        out[i] = a(z[i])\n",
    "    ###########################################################################\n",
    "    #                             END OF YOUR CODE                            #\n",
    "    ###########################################################################\n",
    "    cache = ((x, w, b), (z))\n",
    "    return out, cache\n",
    "\n",
    "# Test the affine_forward function\n",
    "num_inputs = 2\n",
    "input_shape = (4, 5, 6)\n",
    "output_dim = 3\n",
    "\n",
    "input_size = num_inputs * np.prod(input_shape)\n",
    "weight_size = output_dim * np.prod(input_shape)\n",
    "\n",
    "x = np.linspace(-0.1, 0.5, num = input_size).reshape(num_inputs, *input_shape)\n",
    "w = np.linspace(-0.2, 0.3, num = weight_size).reshape(np.prod(input_shape), output_dim)\n",
    "b = np.linspace(-0.3, 0.1, num = output_dim)\n",
    "\n",
    "a = lambda x: x # linear activation\n",
    "out, _ = affine_forward(x, w, b, a)\n",
    "correct_out = np.array([[ 1.49834967,  1.70660132,  1.91485297],\n",
    "                        [ 3.25553199,  3.5141327,   3.77273342]])\n",
    "\n",
    "# Compare your output with ours. The error should be around 1e-9.\n",
    "print('Testing affine_forward function:')\n",
    "print('difference: {}'.format(rel_error(out, correct_out)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Affine layer: backward\n",
    "Now implement the <code>affine_backward</code> function and test your implementation using numeric gradient checking."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Testing affine_backward function:\n",
      "dx error: 2.775066066812339e-11\n",
      "dw error: 8.147071119166524e-11\n",
      "db error: 7.736978834487815e-12\n"
     ]
    }
   ],
   "source": [
    "def affine_backward(dout, da, cache):\n",
    "    \"\"\"\n",
    "    Computes the backward pass for an affine layer.\n",
    "\n",
    "    Inputs:\n",
    "    - dout: Upstream derivative, of shape (N, M)\n",
    "    - da: A function of the derivative of the activation\n",
    "    - cache: Tuple of:\n",
    "      - x: Input data, of shape (N, d_1, ... d_k)\n",
    "      - w: Weights, of shape (D, M)\n",
    "\n",
    "    Returns a tuple of:\n",
    "    - dx: Gradient with respect to x, of shape (N, d1, ..., d_k)\n",
    "    - dw: Gradient with respect to w, of shape (D, M)\n",
    "    - db: Gradient with respect to b, of shape (M,)\n",
    "    \"\"\"\n",
    "    fc_cache, act_cache = cache\n",
    "    x, w, b = fc_cache\n",
    "    z = act_cache\n",
    "    dx, dw, db = None, None, None\n",
    "    ###########################################################################\n",
    "    # TODO: Implement the affine backward pass.                               #\n",
    "    ###########################################################################\n",
    "#     raise NotImplementedError()\n",
    "    \n",
    "    N = x.shape[0]\n",
    "    D = w.shape[0]\n",
    "    M = w.shape[1]\n",
    "    x_reshape = x.reshape((N, D))\n",
    "    dw_N = np.empty((N,D,M))\n",
    "    for i in range(N):\n",
    "        tmp = dout[i] * da(z[i,:])\n",
    "        dw_N[i] = np.matmul(x_reshape[i].reshape((D, 1)), tmp.reshape((1, M)))\n",
    "        \n",
    "#     dw = np.dot(x_reshape.T, (dout * da(z)))        \n",
    "    dw = np.sum(dw_N, axis = 0)\n",
    "    db = dout.sum(axis = 0)\n",
    "    dx = np.dot((dout * da(z)), w.T)\n",
    "    dx = dx.reshape(x.shape)\n",
    "    ###########################################################################\n",
    "    #                             END OF YOUR CODE                            #\n",
    "    ###########################################################################\n",
    "    return dx, dw, db\n",
    "\n",
    "def eval_numerical_gradient_array(f, x, df, h=1e-5):\n",
    "    \"\"\"\n",
    "    Evaluate a numeric gradient for a function that accepts a numpy\n",
    "    array and returns a numpy array.\n",
    "    \"\"\"\n",
    "    grad = np.zeros_like(x)\n",
    "    it = np.nditer(x, flags = ['multi_index'], op_flags = ['readwrite'])\n",
    "    while not it.finished:\n",
    "        ix = it.multi_index\n",
    "\n",
    "        oldval = x[ix]\n",
    "        x[ix] = oldval + h\n",
    "        pos = f(x).copy()\n",
    "        x[ix] = oldval - h\n",
    "        neg = f(x).copy()\n",
    "        x[ix] = oldval\n",
    "\n",
    "        grad[ix] = np.sum((pos - neg) * df) / (2 * h)\n",
    "        it.iternext()\n",
    "    return grad\n",
    "\n",
    "# Test the affine_backward function\n",
    "np.random.seed(231)\n",
    "x = np.random.randn(10, 2, 3)\n",
    "w = np.random.randn(6, 5)\n",
    "b = np.random.randn(5)\n",
    "dout = np.random.randn(10, 5)\n",
    "\n",
    "dx_num = eval_numerical_gradient_array(lambda x: affine_forward(x, w, b, a)[0], x, dout)\n",
    "dw_num = eval_numerical_gradient_array(lambda w: affine_forward(x, w, b, a)[0], w, dout)\n",
    "db_num = eval_numerical_gradient_array(lambda b: affine_forward(x, w, b, a)[0], b, dout)\n",
    "\n",
    "_, cache = affine_forward(x, w, b, a)\n",
    "da = lambda x: 1 # the derivative of linear activation\n",
    "dx, dw, db = affine_backward(dout, da, cache)\n",
    "\n",
    "# The error should be around 1e-10\n",
    "print('Testing affine_backward function:')\n",
    "print('dx error: {}'.format(rel_error(dx_num, dx)))\n",
    "print('dw error: {}'.format(rel_error(dw_num, dw)))\n",
    "print('db error: {}'.format(rel_error(db_num, db)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Two-layer network\n",
    "Now that you have implemented modular versions of the necessary layers, you will reimplement the two layer network using these modular implementations.\n",
    "\n",
    "Complete the implementation of the <code>TwoLayerNet</code> class. This class will serve as a model for the other networks you will implement in this assignment, so read through it to make sure you understand the API. You can run the cell below to test your implementation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Testing initialization ... \n",
      "Testing test-time forward pass ... \n",
      "Testing training loss (no regularization)\n",
      "Running numeric gradient check with reg =  0.0\n",
      "W1 relative error: 1.83e-08\n",
      "W2 relative error: 3.25e-10\n",
      "b1 relative error: 6.55e-09\n",
      "b2 relative error: 4.33e-10\n",
      "Running numeric gradient check with reg =  0.7\n",
      "W1 relative error: 1.00e+00\n",
      "W2 relative error: 1.00e+00\n",
      "b1 relative error: 1.56e-08\n",
      "b2 relative error: 9.09e-10\n"
     ]
    }
   ],
   "source": [
    "# http://ml-cheatsheet.readthedocs.io/en/latest/activation_functions.html\n",
    "acts = {'relu': lambda x: np.maximum(x, 0., x),\n",
    "       'tanh': lambda x: np.tanh(x),\n",
    "       'sigmoid': lambda x: 1 / (1 + np.exp(- x)),\n",
    "       'leaky_relu': lambda x: np.maximum(x, 0.01 * x, x)} # here alpha = 0.01\n",
    "dacts = {'relu': lambda x: np.greater(x, 0),\n",
    "        'tanh': lambda x: (1 - (x ** 2)),\n",
    "        'sigmoid': lambda x: x * (1 - x),\n",
    "        'leaky_relu': lambda x: np.greater(x, 0) * (1 - 0.01) + 0.01}\n",
    "\n",
    "def softmax_loss(x, y):\n",
    "    \"\"\"\n",
    "    Computes the loss and gradient for softmax classification.\n",
    "\n",
    "    Inputs:\n",
    "    - x: Input data, of shape (N, C) where x[i, j] is the score for the jth\n",
    "      class for the ith input.\n",
    "    - y: Vector of labels, of shape (N,) where y[i] is the label for x[i] and\n",
    "      0 <= y[i] < C\n",
    "\n",
    "    Returns a tuple of:\n",
    "    - loss: Scalar giving the loss\n",
    "    - dx: Gradient of the loss with respect to x\n",
    "    \"\"\"\n",
    "    shifted_logits = x - np.max(x, axis = 1, keepdims = True)\n",
    "    Z = np.sum(np.exp(shifted_logits), axis=1, keepdims = True)\n",
    "    log_probs = shifted_logits - np.log(Z)\n",
    "    probs = np.exp(log_probs)\n",
    "    N = x.shape[0]\n",
    "    loss = - np.sum(log_probs[np.arange(N), y]) / N\n",
    "    dx = probs.copy()\n",
    "    dx[np.arange(N), y] -= 1\n",
    "    dx /= N\n",
    "    return loss, dx\n",
    "\n",
    "class TwoLayerNet(object):\n",
    "    \"\"\"\n",
    "    A two-layer fully-connected neural network with ReLU nonlinearity and\n",
    "    softmax loss that uses a modular layer design. We assume an input dimension\n",
    "    of D, a hidden dimension of H, and perform classification over C classes.\n",
    "\n",
    "    The architecure should be affine - relu - affine - softmax.\n",
    "\n",
    "    Note that this class does not implement gradient descent; instead, it\n",
    "    will interact with a separate Solver object that is responsible for running\n",
    "    optimization.\n",
    "\n",
    "    The learnable parameters of the model are stored in the dictionary\n",
    "    self.params that maps parameter names to numpy arrays.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, input_dim = 28 * 28, hidden_dim = 100, num_classes = 10,\n",
    "                 weight_scale = 1e-3, reg = 0.0, act = (acts['relu'], dacts['relu'])):\n",
    "        \"\"\"\n",
    "        Initialize a new network.\n",
    "\n",
    "        Inputs:\n",
    "        - input_dim: An integer giving the size of the input\n",
    "        - hidden_dim: An integer giving the size of the hidden layer\n",
    "        - num_classes: An integer giving the number of classes to classify\n",
    "        - dropout: Scalar between 0 and 1 giving dropout strength.\n",
    "        - weight_scale: Scalar giving the standard deviation for random\n",
    "          initialization of the weights.\n",
    "        - reg: Scalar giving L2 regularization strength.\n",
    "        \"\"\"\n",
    "        self.params = {}\n",
    "        self.reg = reg\n",
    "        self.act = act\n",
    "\n",
    "        ############################################################################\n",
    "        # TODO: Initialize the weights and biases of the two-layer net. Weights    #\n",
    "        # should be initialized from a Gaussian with standard deviation equal to   #\n",
    "        # weight_scale, and biases should be initialized to zero. All weights and  #\n",
    "        # biases should be stored in the dictionary self.params, with first layer  #\n",
    "        # weights and biases using the keys 'W1' and 'b1' and second layer weights #\n",
    "        # and biases using the keys 'W2' and 'b2'.                                 #\n",
    "        ############################################################################\n",
    "#         raise NotImplementedError()\n",
    "        self.params['W1']= np.random.normal(scale=weight_scale, size=(input_dim, hidden_dim))\n",
    "        self.params['b1']= np.zeros((hidden_dim,))\n",
    "        self.params['W2']= np.random.normal(scale=weight_scale, size=(hidden_dim, num_classes))\n",
    "        self.params['b2']= np.zeros((num_classes,))\n",
    "        ############################################################################\n",
    "        #                             END OF YOUR CODE                             #\n",
    "        ############################################################################\n",
    "\n",
    "\n",
    "    def loss(self, X, y = None):\n",
    "        \"\"\"\n",
    "        Compute loss and gradient for a minibatch of data.\n",
    "\n",
    "        Inputs:\n",
    "        - X: Array of input data of shape (N, d_1, ..., d_k)\n",
    "        - y: Array of labels, of shape (N,). y[i] gives the label for X[i].\n",
    "\n",
    "        Returns:\n",
    "        If y is None, then run a test-time forward pass of the model and return:\n",
    "        - scores: Array of shape (N, C) giving classification scores, where\n",
    "          scores[i, c] is the classification score for X[i] and class c.\n",
    "\n",
    "        If y is not None, then run a training-time forward and backward pass and\n",
    "        return a tuple of:\n",
    "        - loss: Scalar value giving the loss\n",
    "        - grads: Dictionary with the same keys as self.params, mapping parameter\n",
    "          names to gradients of the loss with respect to those parameters.\n",
    "        \"\"\"\n",
    "        scores = None\n",
    "        ############################################################################\n",
    "        # TODO: Implement the forward pass for the two-layer net, computing the    #\n",
    "        # class scores for X and storing them in the scores variable.              #\n",
    "        ############################################################################\n",
    "#         raise NotImplementedError()\n",
    "        w1 = self.params['W1']\n",
    "        b1 = self.params['b1']\n",
    "        w2 = self.params['W2']\n",
    "        b2 = self.params['b2']\n",
    "        \n",
    "        w1_shape = w1.shape\n",
    "        w2_shape = w2.shape\n",
    "        D = w1_shape[0]\n",
    "        h = w1_shape[1]\n",
    "        num_c = w2.shape[1]\n",
    "        N = X.shape[0]\n",
    "\n",
    "        X = X.reshape((N,D))\n",
    "        layer1_output, layer1_cache = affine_forward(X, w1, b1, self.act[0])\n",
    "        layer2_output, layer2_cache = affine_forward(layer1_output, w2, b2, lambda x: x)\n",
    "        \n",
    "        scores = layer2_output\n",
    "        ############################################################################\n",
    "        #                             END OF YOUR CODE                             #\n",
    "        ############################################################################\n",
    "\n",
    "        # If y is None then we are in test mode so just return scores\n",
    "        if y is None:\n",
    "            return scores\n",
    "\n",
    "        loss, grads = 0, {}\n",
    "        ############################################################################\n",
    "        # TODO: Implement the backward pass for the two-layer net. Store the loss  #\n",
    "        # in the loss variable and gradients in the grads dictionary. Compute data #\n",
    "        # loss using softmax, and make sure that grads[k] holds the gradients for  #\n",
    "        # self.params[k]. Don't forget to add L2 regularization!                   #\n",
    "        #                                                                          #\n",
    "        # NOTE: To ensure that your implementation matches ours and you pass the   #\n",
    "        # automated tests, make sure that your L2 regularization includes a factor #\n",
    "        # of 0.5 to simplify the expression for the gradient.                      #\n",
    "        ############################################################################\n",
    "#         raise NotImplementedError()\n",
    "        loss, dout = softmax_loss(scores, y)\n",
    "        dout_h, dw2, db2 = affine_backward(dout, lambda x: 1, layer2_cache)\n",
    "        _ , dw1, db1 = affine_backward(dout_h, self.act[1], layer1_cache)\n",
    "        grads['W1'] = dw1\n",
    "        grads['b1'] = db1\n",
    "        grads['W2'] = dw2\n",
    "        grads['b2'] = db2\n",
    "\n",
    "        reg_loss = 0.5 * self.reg * (np.sum(w1 * w1) + np.sum(w2 *w2))\n",
    "        loss += reg_loss\n",
    "        ############################################################################\n",
    "        #                             END OF YOUR CODE                             #\n",
    "        ############################################################################\n",
    "\n",
    "        return loss, grads\n",
    "\n",
    "def eval_numerical_gradient(f, x, verbose=True, h=0.00001):\n",
    "    \"\"\"\n",
    "    a naive implementation of numerical gradient of f at x\n",
    "    - f should be a function that takes a single argument\n",
    "    - x is the point (numpy array) to evaluate the gradient at\n",
    "    \"\"\"\n",
    "\n",
    "    fx = f(x) # evaluate function value at original point\n",
    "    grad = np.zeros_like(x)\n",
    "    # iterate over all indexes in x\n",
    "    it = np.nditer(x, flags=['multi_index'], op_flags=['readwrite'])\n",
    "    while not it.finished:\n",
    "\n",
    "        # evaluate function at x+h\n",
    "        ix = it.multi_index\n",
    "        oldval = x[ix]\n",
    "        x[ix] = oldval + h # increment by h\n",
    "        fxph = f(x) # evalute f(x + h)\n",
    "        x[ix] = oldval - h\n",
    "        fxmh = f(x) # evaluate f(x - h)\n",
    "        x[ix] = oldval # restore\n",
    "\n",
    "        # compute the partial derivative with centered formula\n",
    "        grad[ix] = (fxph - fxmh) / (2 * h) # the slope\n",
    "        if verbose:\n",
    "            print(ix, grad[ix])\n",
    "        it.iternext() # step to next dimension\n",
    "\n",
    "    return grad\n",
    "\n",
    "np.random.seed(231)\n",
    "N, D, H, C = 3, 5, 50, 7\n",
    "X = np.random.randn(N, D)\n",
    "y = np.random.randint(C, size = N)\n",
    "\n",
    "std = 1e-3\n",
    "model = TwoLayerNet(input_dim = D, hidden_dim = H, num_classes = C, weight_scale = std)\n",
    "\n",
    "print('Testing initialization ... ')\n",
    "W1_std = abs(model.params['W1'].std() - std)\n",
    "b1 = model.params['b1']\n",
    "W2_std = abs(model.params['W2'].std() - std)\n",
    "b2 = model.params['b2']\n",
    "assert W1_std < std / 10, 'First layer weights do not seem right'\n",
    "assert np.all(b1 == 0), 'First layer biases do not seem right'\n",
    "assert W2_std < std / 10, 'Second layer weights do not seem right'\n",
    "assert np.all(b2 == 0), 'Second layer biases do not seem right'\n",
    "\n",
    "print('Testing test-time forward pass ... ')\n",
    "model.params['W1'] = np.linspace(-0.7, 0.3, num = D * H).reshape(D, H)\n",
    "model.params['b1'] = np.linspace(-0.1, 0.9, num = H)\n",
    "model.params['W2'] = np.linspace(-0.3, 0.4, num = H * C).reshape(H, C)\n",
    "model.params['b2'] = np.linspace(-0.9, 0.1, num = C)\n",
    "X = np.linspace(-5.5, 4.5, num = N * D).reshape(D, N).T\n",
    "scores = model.loss(X)\n",
    "correct_scores = np.asarray(\n",
    "  [[11.53165108,  12.2917344,   13.05181771,  13.81190102,  14.57198434, 15.33206765,  16.09215096],\n",
    "   [12.05769098,  12.74614105,  13.43459113,  14.1230412,   14.81149128, 15.49994135,  16.18839143],\n",
    "   [12.58373087,  13.20054771,  13.81736455,  14.43418138,  15.05099822, 15.66781506,  16.2846319 ]])\n",
    "scores_diff = np.abs(scores - correct_scores).sum()\n",
    "assert scores_diff < 1e-6, 'Problem with test-time forward pass'\n",
    "\n",
    "print('Testing training loss (no regularization)')\n",
    "y = np.asarray([0, 5, 1])\n",
    "loss, grads = model.loss(X, y)\n",
    "correct_loss = 3.4702243556\n",
    "assert abs(loss - correct_loss) < 1e-10, 'Problem with training-time loss'\n",
    "\n",
    "model.reg = 1.0\n",
    "loss, grads = model.loss(X, y)\n",
    "correct_loss = 26.5948426952\n",
    "\n",
    "\n",
    "if abs(loss - correct_loss) >= 1e-10:\n",
    "    print('Problem with regularization loss')\n",
    "\n",
    "for reg in [0.0, 0.7]:\n",
    "    print('Running numeric gradient check with reg = ', reg)\n",
    "    model.reg = reg\n",
    "    loss, grads = model.loss(X, y)\n",
    "\n",
    "    for name in sorted(grads):\n",
    "        f = lambda _: model.loss(X, y)[0]\n",
    "        grad_num = eval_numerical_gradient(f, model.params[name], verbose = False)\n",
    "        print('%s relative error: %.2e' % (name, rel_error(grad_num, grads[name])))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Solver\n",
    "In the previous assignment, the logic for training models was coupled to the models themselves. Following a more modular design, for this assignment we have split the logic for training models into a separate class.\n",
    "\n",
    "Read through it to familiarize yourself with the API. After doing so, use a <code>Solver</code> instance to train a <code>TwoLayerNet</code> that achieves at least <code>50%</code> accuracy on the validation set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(Iteration 1 / 1200) loss: 2.302664\n",
      "(Epoch 0 / 20) train acc: 0.513000; val_acc: 0.500000\n",
      "(Epoch 1 / 20) train acc: 0.606000; val_acc: 0.613833\n",
      "(Iteration 101 / 1200) loss: 0.468444\n",
      "(Epoch 2 / 20) train acc: 0.758000; val_acc: 0.772833\n",
      "(Epoch 3 / 20) train acc: 0.804000; val_acc: 0.792000\n",
      "(Iteration 201 / 1200) loss: 0.380288\n",
      "(Epoch 4 / 20) train acc: 0.799000; val_acc: 0.789000\n",
      "(Epoch 5 / 20) train acc: 0.818000; val_acc: 0.804000\n",
      "(Iteration 301 / 1200) loss: 0.453961\n",
      "(Epoch 6 / 20) train acc: 0.841000; val_acc: 0.834667\n",
      "(Iteration 401 / 1200) loss: 0.350471\n",
      "(Epoch 7 / 20) train acc: 0.826000; val_acc: 0.829167\n",
      "(Epoch 8 / 20) train acc: 0.822000; val_acc: 0.843667\n",
      "(Iteration 501 / 1200) loss: 0.403349\n",
      "(Epoch 9 / 20) train acc: 0.858000; val_acc: 0.834167\n",
      "(Epoch 10 / 20) train acc: 0.878000; val_acc: 0.855167\n",
      "(Iteration 601 / 1200) loss: 0.296753\n",
      "(Epoch 11 / 20) train acc: 0.859000; val_acc: 0.841667\n",
      "(Iteration 701 / 1200) loss: 0.275567\n",
      "(Epoch 12 / 20) train acc: 0.866000; val_acc: 0.853667\n",
      "(Epoch 13 / 20) train acc: 0.865000; val_acc: 0.853833\n",
      "(Iteration 801 / 1200) loss: 0.335303\n",
      "(Epoch 14 / 20) train acc: 0.871000; val_acc: 0.868500\n",
      "(Epoch 15 / 20) train acc: 0.899000; val_acc: 0.870000\n",
      "(Iteration 901 / 1200) loss: 0.306620\n",
      "(Epoch 16 / 20) train acc: 0.880000; val_acc: 0.861333\n",
      "(Iteration 1001 / 1200) loss: 0.248325\n",
      "(Epoch 17 / 20) train acc: 0.874000; val_acc: 0.862667\n",
      "(Epoch 18 / 20) train acc: 0.876000; val_acc: 0.864833\n",
      "(Iteration 1101 / 1200) loss: 0.292528\n",
      "(Epoch 19 / 20) train acc: 0.874000; val_acc: 0.870500\n",
      "(Epoch 20 / 20) train acc: 0.879000; val_acc: 0.871667\n"
     ]
    },
    {
     "data": {
      "image/png": "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